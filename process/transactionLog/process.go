package transactionLog

import (
	"encoding/hex"

	logger "github.com/ElrondNetwork/elrond-go-logger"
	"github.com/ElrondNetwork/elrond-go/core/check"
	"github.com/ElrondNetwork/elrond-go/data"
	"github.com/ElrondNetwork/elrond-go/data/transaction"
	"github.com/ElrondNetwork/elrond-go/marshal"
	"github.com/ElrondNetwork/elrond-go/process"
	"github.com/ElrondNetwork/elrond-go/storage"
	vmcommon "github.com/ElrondNetwork/elrond-vm-common"
)

var log = logger.GetOrCreate("process/transactionLog")

// ArgTxLogProcessor defines the arguments needed for transaction logs processor
type ArgTxLogProcessor struct {
	Storer storage.Storer
	Marshalizer marshal.Marshalizer
}

type txLogProcessor struct {
	storer storage.Storer
	marshalizer marshal.Marshalizer
}

// NewTxLogProcessor creates a transaction log processor capable of parsing logs from the VM
//  and saving them into the injected storage
func NewTxLogProcessor(args ArgTxLogProcessor) (process.TransactionLogProcessor, error) {
	if check.IfNil(args.Storer) {
		return nil, process.ErrNilStore
	}
	if check.IfNil(args.Marshalizer) {
		return nil, process.ErrNilMarshalizer
	}

	return &txLogProcessor{
		storer: args.Storer,
		marshalizer: args.Marshalizer,
	}, nil
}

// GetLog retreives a log generated by a transaction
func (tlp *txLogProcessor) GetLog(txHash []byte) (data.LogHandler, error) {
	txLogBuff, err := tlp.storer.Get(txHash)
	if err != nil {
		return nil, process.ErrLogNotFound
	}

	var txLog data.LogHandler
	err = tlp.marshalizer.Unmarshal(txLog, txLogBuff)
	if err != nil {
		return nil, err
	}

	return txLog, nil
}

// SaveLog takes the VM logs and saves them into the correct format in storage
func (tlp *txLogProcessor) SaveLog(txHash []byte, tx data.TransactionHandler, logEntries []*vmcommon.LogEntry) error {
	if len(txHash) == 0 {
		return process.ErrNilTxHash
	}

	if check.IfNil(tx) {
		return process.ErrNilTransaction
	}

	if len(logEntries) == 0 {
		log.Debug("txLogProcessor.SaveLog()",
			"txHash", hex.EncodeToString(txHash),
			"message", "no logEntries provided",
		)

		return nil
	}

	txLog := &transaction.Log{
		Address: tx.GetRcvAddr(),
	}

	events := make([]*transaction.Event, len(logEntries))
	for i, vmLog := range logEntries {
		events[i] = tlp.computeEvent(vmLog)
	}
	txLog.Events = events

	buff, err := tlp.marshalizer.Marshal(txLog)
	if err != nil {
		return err
	}

	return tlp.storer.Put(txHash, buff)
}

func (tlp *txLogProcessor) computeEvent(logEntry *vmcommon.LogEntry) *transaction.Event {
	event := &transaction.Event {
		Address: logEntry.Address,
		Data:    logEntry.Data,
	}

	topicsLen := len(logEntry.Topics)
	if topicsLen == 0 {
		return event
	}
	event.Identifier = logEntry.Topics[0]

	if topicsLen == 1 {
		return event
	}
	event.Topics = logEntry.Topics[1:]

	return event
}

// IsInterfaceNil returns true if there is no value under the interface
func (tlp *txLogProcessor) IsInterfaceNil() bool {
	return tlp == nil
}

