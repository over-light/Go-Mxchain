package block

import (
	"math/rand"

	"github.com/ElrondNetwork/elrond-go-sandbox/data"
	"github.com/ElrondNetwork/elrond-go-sandbox/data/block/capnproto"
	"zombiezen.com/go/capnproto2"
	"github.com/sirupsen/logrus"
)

var log = logrus.WithField("prefix", "header")

type Header struct {
	Nonce    []byte
	PrevHash []byte
	// temporary keep list of public keys of signers in header
	// to be removed later
	PubKeys    [][]byte
	ShardId    uint32
	TimeStamp  []byte
	Round      uint32
	BlockHash  []byte
	Signature  []byte
	Commitment []byte
}

func (h *Header) CopyToCapnpStruct(s *capnp.Segment) error {
	if s == nil {
		log.Fatalf("segment pointer received is nil")
	}
	header, err := capnproto.NewHeaderCapnp(s)

	if err != nil {
		return err
	}

	header.SetNonce(h.Nonce)
	header.SetPrevHash(h.PrevHash)
	header.SetShardId(h.ShardId)
	header.SetTimeStamp(h.TimeStamp)
	header.SetRound(h.Round)
	header.SetBlockHash(h.BlockHash)
	header.SetSignature(h.Signature)
	header.SetCommitment(h.Commitment)

	numPk := 0/*len(h.PubKeys)*/
	pkList, _ := header.NewPubKeys(0 /*int32(numPk)*/)

	for i := 0; i < numPk; i++ {
		pkList.Set(i, h.PubKeys[i])
	}

	err = header.SetPubKeys(pkList /*pkList*/)

	return err
}

func (h *Header) CopyFromCapnpStruct(m *capnp.Message) error {

	header, err := capnproto.ReadRootHeaderCapnp(m)

	if err != nil {
		return err
	}

	h.Nonce, _ = header.Nonce()
	h.PrevHash, _ = header.PrevHash()
	h.ShardId = header.ShardId()
	h.TimeStamp, _ = header.TimeStamp()
	h.Round = header.Round()
	h.BlockHash, _ = header.BlockHash()
	h.Signature, _ = header.Signature()
	h.Commitment, _ = header.Commitment()

	pkList, _ := header.PubKeys()

	for i := 0; i < pkList.Len(); i++ {
		h.PubKeys[i], _ = pkList.At(i)
	}

	return nil
}

// used for tests
func (h Header) GenerateDummyDataArray() []data.CapnpHelper {
	headers := make([]data.CapnpHelper, 0, 1000)

	pkList := make([][]byte, 0, 21)

	for i := 0; i < 21; i++ {
		pkList = append(pkList, []byte(data.RandomStr(32)))
	}

	for i := 0; i < 1000; i++ {
		headers = append(headers, &Header{
			Nonce:      []byte(data.RandomStr(4)),
			PrevHash:   []byte(data.RandomStr(32)),
			ShardId:    uint32(rand.Intn(20)),
			TimeStamp:  []byte(data.RandomStr(20)),
			Round:      uint32(rand.Intn(3000)),
			BlockHash:  []byte(data.RandomStr(32)),
			Signature:  []byte(data.RandomStr(32)),
			Commitment: []byte(data.RandomStr(32)),
			PubKeys:    pkList,
		})
	}

	return headers
}
