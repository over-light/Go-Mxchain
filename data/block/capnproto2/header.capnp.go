// Code generated by capnpc-go. DO NOT EDIT.

package capnproto2

import (
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// header information, attachable to blocks or miniblocks
type HeaderCapnp struct{ capnp.Struct }

// HeaderCapnp_TypeID is the unique identifier for the type HeaderCapnp.
const HeaderCapnp_TypeID = 0xe95bb16f30c95e7e

func NewHeaderCapnp(s *capnp.Segment) (HeaderCapnp, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return HeaderCapnp{st}, err
}

func NewRootHeaderCapnp(s *capnp.Segment) (HeaderCapnp, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return HeaderCapnp{st}, err
}

func ReadRootHeaderCapnp(msg *capnp.Message) (HeaderCapnp, error) {
	root, err := msg.RootPtr()
	return HeaderCapnp{root.Struct()}, err
}

func (s HeaderCapnp) String() string {
	str, _ := text.Marshal(0xe95bb16f30c95e7e, s.Struct)
	return str
}

func (s HeaderCapnp) Nonce() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasNonce() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetNonce(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s HeaderCapnp) PrevHash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasPrevHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetPrevHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s HeaderCapnp) PubKeys() (capnp.DataList, error) {
	p, err := s.Struct.Ptr(2)
	return capnp.DataList{List: p.List()}, err
}

func (s HeaderCapnp) HasPubKeys() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetPubKeys(v capnp.DataList) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewPubKeys sets the pubKeys field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s HeaderCapnp) NewPubKeys(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

func (s HeaderCapnp) ShardId() uint32 {
	return s.Struct.Uint32(0)
}

func (s HeaderCapnp) SetShardId(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s HeaderCapnp) TimeStamp() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasTimeStamp() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetTimeStamp(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s HeaderCapnp) Round() uint32 {
	return s.Struct.Uint32(4)
}

func (s HeaderCapnp) SetRound(v uint32) {
	s.Struct.SetUint32(4, v)
}

func (s HeaderCapnp) BlockHash() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasBlockHash() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetBlockHash(v []byte) error {
	return s.Struct.SetData(4, v)
}

func (s HeaderCapnp) Signature() ([]byte, error) {
	p, err := s.Struct.Ptr(5)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasSignature() bool {
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetSignature(v []byte) error {
	return s.Struct.SetData(5, v)
}

func (s HeaderCapnp) Commitment() ([]byte, error) {
	p, err := s.Struct.Ptr(6)
	return []byte(p.Data()), err
}

func (s HeaderCapnp) HasCommitment() bool {
	p, err := s.Struct.Ptr(6)
	return p.IsValid() || err != nil
}

func (s HeaderCapnp) SetCommitment(v []byte) error {
	return s.Struct.SetData(6, v)
}

// HeaderCapnp_List is a list of HeaderCapnp.
type HeaderCapnp_List struct{ capnp.List }

// NewHeaderCapnp creates a new list of HeaderCapnp.
func NewHeaderCapnp_List(s *capnp.Segment, sz int32) (HeaderCapnp_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7}, sz)
	return HeaderCapnp_List{l}, err
}

func (s HeaderCapnp_List) At(i int) HeaderCapnp { return HeaderCapnp{s.List.Struct(i)} }

func (s HeaderCapnp_List) Set(i int, v HeaderCapnp) error { return s.List.SetStruct(i, v.Struct) }

func (s HeaderCapnp_List) String() string {
	str, _ := text.MarshalList(0xe95bb16f30c95e7e, s.List)
	return str
}

// HeaderCapnp_Promise is a wrapper for a HeaderCapnp promised by a client call.
type HeaderCapnp_Promise struct{ *capnp.Pipeline }

func (p HeaderCapnp_Promise) Struct() (HeaderCapnp, error) {
	s, err := p.Pipeline.Struct()
	return HeaderCapnp{s}, err
}

const schema_9096faa5d587481d = "x\xdaD\xd0Ak\xd4@\x1c\x05\xf0\xf7&\xc9\xee\x1e" +
	"l\xd9\x90\x80\x0a-\x1b\xa4B\x0f\xd5\xed\xd6K\x11D" +
	"\xad\x97U/\x1dsS(\xccf\xa3\x1b\xba\xc9\x84d" +
	"V\xf0b\x8f\x82'A\xf0\xea\xc9\x0f\xe0U\xf0\xe8\xc1" +
	"\x0f\xa0\x9fA\x0f\x05\x0b\xbd(BdR\xd6\x1e\xdf\x8f" +
	"\xf7\x98\xe1\xdf?\xbe#F\xdeE\x01\xc8K^\xa7y" +
	"y\xf0u[\x7f|\xf2\x13\xf2\x0a\xd9\xac\x8f_}\xfb" +
	"\xf0\xe7\xdd\x1bx\xdd.0:\xa9\x18x\xec\x06\x1e\x07" +
	"7n\xb1!v\x9b\xa92j8\x99k79\x1c&" +
	"\xaa,\xcaJ\x1b=\x9c\xa5j\x9aV\xd7[\xb89n" +
	"\xc3\xe0\x9e\x0d\xfb\xa4t)\x9a\x83\xb7\xef\xe5\xe7\xef\xaf" +
	"\xbf@\xba\x82w7\xc9\x0b\xc0\x88\x9f\xd8\x9c-\xa3\xcc" +
	"+\x9e\xea*W&\xd3\xc5V\xa4\x8cQ\xc9LM\xe6" +
	"idt4\x99\xeb\xe4\xb0\x8et\x15\xe5Y\x91\xdd>" +
	"\x8b\x80\xdcp\\\xc0%\xe0\x1f\xef\x00\xf2\x87Cy*" +
	"\xe8\x93!-\x9e<\x00\xe4/\x87\xf2\xaf\xa0/DH" +
	"\x01\xf8\xbf\xf7\x00y\xea0\xeeS\x90NH\x07\x08V" +
	"\xb8\x07\xc4=:\x8cC\x0a\xfa\xae\x13\xd2\x05\x02\x9f\x8f" +
	"\x80\xb8o}\xcd\xba\xc7\x90\x1e\x10\\\xe6\x0e\x10\x87\xd6" +
	"#\xeb\x1d7d\x07\x08\xd6\xdb\xfe\x9a\xf5M\xeb]/" +
	"d\x17\x08\xae\xb6\xbea}\xdbz\xaf\x13\xb2\x07\x04\xd7" +
	"\xf8\x18\x88\xb7\xac\xefRpP\xe8\"I\xb9\x02\xc1\x15" +
	"\xb0)\xab\xf4\xf9X\xd53\x00K;*\x17\x93\x87\xe9" +
	"\x8b\x9a\xab\xe0\xbe\xc3\x96W\xc1\xa3z\xa6\xaa\xe9\xfd)" +
	"{\x10\xec\x81\x8d\xc9\xf246*\x07\xcb\xe5tP\xe9" +
	"Eq\xdeh\x8f8V58\xfb\xff`\x9d=+\x94" +
	"YT\xe0\xf9'\x12\x9d\xe7\x99\xc9S8\x85Y\xe2\xbf" +
	"\x00\x00\x00\xff\xff\x8f\xc6z\x1c"

func init() {
	schemas.Register(schema_9096faa5d587481d,
		0xe95bb16f30c95e7e)
}
